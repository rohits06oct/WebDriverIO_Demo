"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = exports.CucumberAdapter = exports.default = void 0;

var Cucumber = _interopRequireWildcard(require("cucumber"));

var _mockery = _interopRequireDefault(require("mockery"));

var _isGlob = _interopRequireDefault(require("is-glob"));

var _glob = _interopRequireDefault(require("glob"));

var _path = _interopRequireDefault(require("path"));

var _reporter = _interopRequireDefault(require("./reporter"));

var _events = require("events");

var _utils = require("@wdio/utils");

var _constants = require("./constants");

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class CucumberAdapter {
  constructor(cid, config, specs, capabilities, reporter) {
    this.cwd = process.cwd();
    this.cid = cid;
    this.specs = specs;
    this.reporter = reporter;
    this.capabilities = capabilities;
    this.config = config;
    this.cucumberOpts = Object.assign(_constants.DEFAULT_OPTS, config.cucumberOpts);
    this._hasTests = true;
    this.cucumberFeaturesWithLineNumbers = this.config.cucumberFeaturesWithLineNumbers || [];
  }

  async init() {
    try {
      this.eventBroadcaster = new _events.EventEmitter();
      const reporterOptions = {
        capabilities: this.capabilities,
        ignoreUndefinedDefinitions: Boolean(this.cucumberOpts.ignoreUndefinedDefinitions),
        failAmbiguousDefinitions: Boolean(this.cucumberOpts.failAmbiguousDefinitions),
        tagsInTitle: Boolean(this.cucumberOpts.tagsInTitle)
      };
      this.cucumberReporter = new _reporter.default(this.eventBroadcaster, reporterOptions, this.cid, this.specs, this.reporter);
      const featurePathsToRun = this.cucumberFeaturesWithLineNumbers.length > 0 ? this.cucumberFeaturesWithLineNumbers : this.specs;
      const pickleFilter = new Cucumber.PickleFilter({
        featurePaths: featurePathsToRun,
        names: this.cucumberOpts.name,
        tagExpression: this.cucumberOpts.tagExpression
      });
      this.testCases = await Cucumber.getTestCasesFromFilesystem({
        cwd: this.cwd,
        eventBroadcaster: this.eventBroadcaster,
        featurePaths: this.specs,
        order: this.cucumberOpts.order,
        pickleFilter
      });
      this._hasTests = this.testCases.length > 0;
    } catch (runtimeError) {
      await (0, _utils.executeHooksWithArgs)(this.config.after, [runtimeError, this.capabilities, this.specs]);
      throw runtimeError;
    }

    return this;
  }

  hasTests() {
    return this.config.featureFlags.specFiltering === false || this._hasTests;
  }

  async run() {
    let runtimeError;
    let result;

    try {
      var _context;

      this.registerRequiredModules();
      Cucumber.supportCodeLibraryBuilder.reset(this.cwd);
      this.addWdioHooks(this.config);
      this.loadSpecFiles();
      this.wrapSteps(this.config);
      (0, _utils2.setUserHookNames)(Cucumber.supportCodeLibraryBuilder.options);
      Cucumber.setDefaultTimeout(this.cucumberOpts.timeout);
      const supportCodeLibrary = Cucumber.supportCodeLibraryBuilder.finalize();
      this.getCurrentStep = (_context = this.cucumberReporter.eventListener).getCurrentStep.bind(_context);
      const runtime = new Cucumber.Runtime({
        eventBroadcaster: this.eventBroadcaster,
        options: this.cucumberOpts,
        supportCodeLibrary,
        testCases: this.testCases
      });
      result = (await runtime.start()) ? 0 : 1;

      if (this.cucumberOpts.ignoreUndefinedDefinitions && result) {
        result = this.cucumberReporter.failedCount;
      }
    } catch (e) {
      runtimeError = e;
      result = 1;
    }

    await (0, _utils.executeHooksWithArgs)(this.config.after, [runtimeError || result, this.capabilities, this.specs]);

    if (runtimeError) {
      throw runtimeError;
    }

    return result;
  }

  registerRequiredModules() {
    this.cucumberOpts.requireModule.map(requiredModule => {
      if (Array.isArray(requiredModule)) {
        require(requiredModule[0])(requiredModule[1]);
      } else if (typeof requiredModule === 'function') {
        requiredModule();
      } else {
        require(requiredModule);
      }
    });
  }

  requiredFiles() {
    return this.cucumberOpts.require.reduce((files, requiredFile) => files.concat((0, _isGlob.default)(requiredFile) ? _glob.default.sync(requiredFile) : [requiredFile]), []);
  }

  loadSpecFiles() {
    _mockery.default.enable({
      useCleanCache: false,
      warnOnReplace: false,
      warnOnUnregistered: false
    });

    _mockery.default.registerMock('cucumber', Cucumber);

    this.requiredFiles().forEach(codePath => {
      const filepath = _path.default.isAbsolute(codePath) ? codePath : _path.default.join(process.cwd(), codePath);
      delete require.cache[require.resolve(filepath)];

      require(filepath);
    });

    _mockery.default.disable();
  }

  addWdioHooks(config) {
    Cucumber.Before(function wdioHookBeforeScenario({
      sourceLocation,
      pickle
    }) {
      const {
        uri,
        feature
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.beforeScenario, [uri, feature, pickle, sourceLocation]);
    });
    Cucumber.After(function wdioHookAfterScenario({
      sourceLocation,
      pickle,
      result
    }) {
      const {
        uri,
        feature
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.afterScenario, [uri, feature, pickle, result, sourceLocation]);
    });
    Cucumber.BeforeAll(function wdioHookBeforeFeature() {
      const {
        uri,
        feature,
        scenarios
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.beforeFeature, [uri, feature, scenarios]);
    });
    Cucumber.AfterAll(function wdioHookAfterFeature() {
      const {
        uri,
        feature,
        scenarios
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.afterFeature, [uri, feature, scenarios]);
    });
  }

  wrapSteps(config) {
    const wrapStep = this.wrapStep;
    const cid = this.cid;

    const getCurrentStep = () => this.getCurrentStep();

    Cucumber.setDefinitionFunctionWrapper((fn, options = {}) => {
      if (fn.name.startsWith('wdioHook')) {
        return fn;
      }

      const isStep = !fn.name.startsWith('userHook');
      const retryTest = isStep && isFinite(options.retry) ? parseInt(options.retry, 10) : 0;
      return wrapStep(fn, retryTest, isStep, config, cid, getCurrentStep);
    });
  }

  wrapStep(code, retryTest = 0, isStep, config, cid, getCurrentStep) {
    return function (...args) {
      const {
        uri,
        feature
      } = (0, _utils2.getDataFromResult)(global.result);
      const beforeFn = isStep ? config.beforeStep : config.beforeHook;
      const afterFn = isStep ? config.afterStep : config.afterHook;
      return _utils.testFnWrapper.call(this, isStep ? 'Step' : 'Hook', {
        specFn: code,
        specFnArgs: args
      }, {
        beforeFn,
        beforeFnArgs: context => [uri, feature, getCurrentStep(), context]
      }, {
        afterFn,
        afterFnArgs: context => [uri, feature, getCurrentStep(), context]
      }, cid, retryTest);
    };
  }

}

exports.CucumberAdapter = CucumberAdapter;
const _CucumberAdapter = CucumberAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;

adapterFactory.init = async function (...args) {
  const adapter = new _CucumberAdapter(...args);
  const instance = await adapter.init();
  return instance;
};

var _default = adapterFactory;
exports.default = _default;